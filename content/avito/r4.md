+++
title = "Языки программирования, про которые вы (возможно) не знали — выпуск 4"
date = 2021-03-08
draft = true
+++

### Язык первый, практичный — OCaml

Сайт: <https://ocaml.org>

> OCaml is an industrial-strength programming language supporting functional, imperative and
> object-oriented styles
>
— *Официальный сайт OCaml*

#### Summary {#ocaml-summary}

OCaml — это самый популярный из императивных ML-подобных языков. Он интересным образом сочетает в
себе черты императивного (отсутствие чистых функций, ввод-вывод без церемоний) и функционального
(переменные — это функции, отсутствие statements, автоматическое каррирование) стиля программирования.
У него довольно большая экосистема, а ещё есть языки, основанные на OCaml — например, [Reason] для
фронтенд-программирования.

[Reason]: https://reasonml.github.io/

#### Как выглядит? {#ocaml-looks}

```ocaml
let type_has_state (cx:ctxt) (t:Ast.ty) : bool =
  layer_le (type_layer cx t) Ast.LAYER_state
;;

(* Various type analyses. *)

let is_prim_type (t:Ast.ty) : bool =
  match t with
      Ast.TY_int
    | Ast.TY_uint
    | Ast.TY_char
    | Ast.TY_mach _
    | Ast.TY_bool
    | Ast.TY_native _ -> true
    | _ -> false
;;

let type_contains_chan (cx:ctxt) (t:Ast.ty) : bool =
  let fold_chan _ = true in
  let fold = ty_fold_bool_or false in
  let fold = { fold with ty_fold_chan = fold_chan } in
    htab_search_or_add cx.ctxt_type_contains_chan_cache t
      (fun _ -> fold_ty cx fold t)
;;
```
*Угадайте, что это за код.*

#### Хайлайты {#ocaml-highlights}

* OCaml — компилируемый, строго и статически типизированный язык программирования. В нём доступен
  полиморфизм через классичекое наследование.

  Это императивный язык, в том смысле, что в нём нет [чистых функций](@/avito/s1.md#pure-functional).
  Тем не менее, OCaml также имеет много признаков функционального языка — он построен на выражениях,
  использует иммутабельные значения по умолчанию, и не различает функций и переменных.

* Как можно «не различать» функции и переменные? Рассмотрим такой код:

  ```ocaml
  (* Я не знаю, зачем я запомнил столько знаков *)
  let pi = 3.1415926535897932384
  ```

  Значение «переменной» `pi` не выделено в памяти (зачем? оно всё равно иммутабельное), компилятор
  просто запомнил, что на место использований `pi` можно подставить значение `3.14...`. Таким образом,
  `pi` можно рассматривать и как переменную (константу), и как функцию без аргументов.

* Чтобы это работало, в OCaml (и в ML-подобных языках вообще) синтаксис вызова функции не требует
  скобок и запятых. Аргументы просто перечисляются через пробел:

  ```ocaml
  (* И в объявлении функции *)
  let average a b =
    let sum = a +. b in
	  sum /. 2.0
  ;;

  (* И в её вызове *)
  let pau = average pi tau ;;

  (* Кстати, объявление вложенной функции ничем не отличается
     от объявления локальной переменной *)

  let med x y =
    let max x y = if x > y then x else y in
	let min x y = if x < y then x else y in
	x + y - (max x y) - (min x y)
  ;;
  ```
  *Да, это отсылка к [xkcd](https://xkcd.com/1292/).*

* В предыдущем cниппете можно заметить интересное свойство OCaml — так как он «очень строго»
  типизированный, то обычные арифметические операторы работают только на целых числах. Для дробных
  чисел нам пришлось писать специальный оператор `+.`. Также мы не можем просто написать `2` и ожидать,
  что мы получим `float` с таким значением — литерал `2` имеет тип `int`, и он не может сам по себе
  стать `float`.

* Несмотря на то, что OCaml статически типизированный, нам не пришлось пока что написать ни одного
  типа. Это связано с тем, что язык поддерживает _глобальный вывод типов_ — в большинстве случаев
  компилятор может просто угадать, какие типы где нужны. Несмотря на это, во многих стайлгайдах
  принято в явном виде писать типы для публичных функций — это помогает читаемости кода.

* Документация OCaml утверждает, что объявления через `let` в OCaml это объявления в фукнциональном стиле:
  `let a = b` читается не как «положить в переменную `a` значение `b`», а как «вместо `a` в дальнейшем
  коде можно подставить `b`».

  Это не вполне правда: следующий сниппет

  ```ocaml
  let foo = print_endline "Hello, world!" ;;
  foo ;;
  foo ;;
  ```

  выведет текст на экран один раз, а не два. В `foo` же будет лежать просто [unit type].

* Если же какое-то значение всё-таки должно быть изменяемым, то в OCaml есть _references_, которые
  чем-то похожи на указатели из C:

  ```ocaml
  let foo = ref 0 ;;
  foo := 1 ;;
  print_endline (string_of_int !foo) ;;
  ```

* Функции в OCaml, как и в многих других ML-подобных языках, автоматически каррируются — например,
  выражение `average 42.` будет иметь тип «функция из `float` в `float`» и производить операцию
  `((x +. 42.) /. 2.)`. Это, опять же, возможно благодаря вызову функций без скобок и запятых:
  в классическом синтаксисе для вызова каррированных функций пришлось бы писать что-то вроде `average(2)(3)`.

* Кроме классических фич императивных и функциональных языков, OCaml также поддерживает ООП с привычными
  классами, методами и наследованием:

  ```ocaml
  class ['a] stack =
    object (self)
      val mutable list = ([] : 'a list)    (* instance variable *)
      method push x =                      (* push method *)
        list <- x :: list
      method pop =                         (* pop method *)
        let result = List.hd list in
        list <- List.tl list;
        result
      method peek =                        (* peek method *)
        List.hd list
      method size =                        (* size method *)
        List.length list
  end;;
  ```

* Тип `int` в OCaml на современных компьютерах имеет 63 бита. Один бит выделяется под задачи
  сборки мусора.

* Обработка ошибок происходит с помощью обычных исключений, которые можно бросать функцией `raise`
  и ловить через `try-with`.

* Как в императивном языке, в OCaml можно записать в одной функции несколько выражений, разделив
  их `;`. В отличие от большинства императивных языков, `;` это не специальная синтаксическая
  конструкция, а просто оператор, который возвращает свой второй аргумент. Таким образом, функция:

  ```ocaml
  let func =
      do_stuff();
	  do_other_stuff();
	  do_third_thing()
  ;;
  ```

  содержит ровно одно выражение, которое вызывает три функции и возвращает значение последней вызванной.

* У OCaml достаточно большая и зрелая экосистема пакетов, что делает его хорошим выбором, если нужен
  достаточно простой императивный язык, поддерживающий при этом много функциональных фичей вроде
  каррирования и паттерн-матчинга.

* Первый компилятор Rust (под названием `rust-boot`) когда-то был написан на OCaml. Сниппет из предыдущей
  секции — как раз часть [этого кода][rust-boot].

[unit type]: @/avito/s1.md#unit-type
[rust-boot]: https://github.com/rust-lang/rust/tree/ef75860a0a72f79f97216f8aaa5b388d98da6480/src/boot

### Язык второй, исследовательский — Verona {#verona}

Сайт: <https://microsoft.github.io/verona/>

> Project Verona is a research programming language to explore the concept of concurrent ownership.
>
— *Официальный сайт Verona*

#### Summary {#verona-summary}

Verona — исследовательский язык программирования, который появился, чтобы изучить перспективы
использования концепции _владения_ (ownership) для конкуретного программирования. Благодаря более
сложному, чем у Rust, рантайму и _коллективному владению_, он пробует предоставить возможность
имплементировать конкурентные системы без использования «небезопасного» кода. В отличие от Pony,
Verona не построена на акторах.

#### Как выглядит? {#verona-looks}

```verona
class Fib
{
  fib(x: U64 & imm): cown[U64Obj] & imm
  {
    var pw = Promise.create();
    var pr = (mut-view pw).wait_handle();

    if (x < 2)
    {
      pw.fulfill(U64Obj.create(1));
    } 
    else
    {
      when () 
      {
        var p1 = Fib.fib(x - 1);
        var p2 = Fib.fib(x - 2);
        // Вот этот синтаксис — отличительная черта Verona.
        // Он позволяет выполнить некий блок кода, когда выполнятся
        // p1 и p2, и одновременно управляет владением.
        when (p1, p2) {
          var r = U64Obj.create(p1.v + p2.v);
          pw.fulfill(r)
        }
      }
    };
    pr
  }
}
```

Да, у меня в блоге работает подсветка синтаксиса Verona. Спасибо [syntect] за его расширяемость.

#### Хайлайты {#verona-highlights}

* Verona — статически типизированный, интерпретируемый язык. Основная её фича заключается в использовании
  системы reference capabilities (чем-то напоминающей Pony), которая позволяет статически гарантировать
  безопасный конкурентный доступ к памяти.

* Одна из серьёзных проблем Rust, которым во многом была вдохновлена Verona, заключается в следующем:

  ```rust
  // Есть структура `Node`, которая живёт не больше `'a`
  struct Node<'a> {
      // В ней есть ссылка на следующую ноду, которая должна
      // прожить не меньше, чем эта нода
      next: &'a Node<'a>,
  }

  let mut n1 = Node { next: None };
  let n2 = Node { next: Some(&n1) };
  // Зацикливаем связный список
  // Это ошибка: `n2` сейчас «смотрит» на `n1`, и мы не имеем
  // права менять объект, на который кто-то «смотрит»
  n1.next = n2;
  ```

  Это ограничение нужно, чтобы предотвратить возможность data races — в самом деле, если мы имеем
  право менять значение, на которое у кого-то ещё есть ссылка, то мы можем поменять его в тот же
  момент, в который происходит чтение, и произойдёт что-то невалидное.

  Verona решает эту проблему с помощью концепта, который называется _регионами_:
  
  ```verona
  class Node
  {
      next: (Node & mut) | (None & imm);
  }

  var r1 = new Node;
  // Мы создаём ноду `r2` в том же *регионе*, что и `r1`
  var r2 = new Node in r1;
  ```

[syntect]: https://crates.io/crates/syntect

<!-- vim: set ts=4 sw=4 et: -->
