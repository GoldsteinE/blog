+++
title = "ЯППВ(В)НЗ — спешл 1. Высокоуровневый глоссарий или большая шпаргалка"
date = 2021-03-04

[extra]
toc = true
+++

Чтобы осмысленно говорить о разных языках программирования, нужно понимать некоторые общие
концепции, связанные с тем, как языки программирования вообще устроены. В этом выпуске представлен
глоссарий по высокоуровневым концепциям дизайна языков программирования.

<!-- more -->

### [Типизация](#types) {#types}

#### <!-- {{{ --> [Алгебраические типы или ADT](#adt) {#adt}

Алгебраические типы данных подразумевают возможность определения в языке _типа-суммы_ и
_типа-произведения_.

Представим себе простой тип `Trit`, у которого есть три значения: `true`, `false` и `unk`.
Если мы объявим обычную структуру с двумя полями типа `Trit`:

```go
type Mul struct {
    x Trit,
    y Trit,
}
```

то у этой структуры будет 9 возможных значений — каждое поле может, независимо от другого, принимать
три значения. Так как количество значений структуры — _произведение_ количества значений всех её
полей, структура является _типом-произведением_. Все поля типа-произведения имеют значение
одновременно.

Тип-сумма — это тип, у которого одновременно имеет значение только одно поле (_вариант_), и мы
в рантайме знаем какой это вариант. Тот вариант, который в данный момент имеет значение, называется
_активным_.

Например, такой тип

```rust
enum Sum {
    A(Trit),
    B(Trit),
}
```

имеет 6 значений — либо это может быть вариант `Sum::A`, либо `Sum::B`, и в каждом случае в поле
может лежать три разных значения. Таким образом, получается ровно 6 значений:

1. `A(false)`
2. `A(true)`
3. `A(unk)`
4. `B(false)`
5. `B(true)`
6. `B(unk)`

Можно заметить, что это _сумма_ количеств значений всех вариантов типа.

Следует отличать тип-сумму от типа-объединения (представленного, например, в TypeScript или Python). 
Такая запись в Python:

```python
Sum = Union[Trit, Trit]
```

была бы эквивалентна просто `Trit` и имела бы 3 значения, а не 6. Чтобы эмулировать тип-сумму в
MyPy, пришлось бы напиать что-то вроде:

```python
@dataclass
class A:
    val: Trit

@dataclass
class B:
    val: Trit

Sum = Union[A, B]
```

##### [Unit type](#unit-type) {#unit-type}

Вырожденный случай типа-произведения это unit type, тип, у которого есть ровно одно значение:

```go
type Unit struct {}
```

Можно заметить, что добавление такого типа как поля к любому типу-произведению не меняет количество
значений последнего: в самом деле, домножение количества значений на один оставляет его прежним.

##### [Bottom type](#bottom-type) {#bottom-type}

Вырожденный случай типа-суммы это bottom type (иногда также называемый void type, но не надо его
путать с `void` из C — `void` из C это вообще не тип). Bottom type имеет _ноль_ значений:

```rust
enum Void {}
```

Так как bottom type не имеет значений, то инициализировать его нельзя, и статически известно, что
если в каком-то месте программы инициализированная переменная имеет тип void, то это место вообще
никогда не выполняется.

Можно заметить, что добавление bottom type в качестве варианта к типу-сумме не меняет количества
его значений: вариант, в котором лежит bottom type никогда не может быть активен, потому что это
потребовало бы предоставить значение этого типа, что невозможно. Добавление же bottom type
как поля к типу-произведению делает весь тип-произведение bottom type (или _ненаселённым_):
создание структуры становится невозможным, потому что это потребовало бы дать какое-то значение
полю, у которого не может быть значений. Это соответствует операциям добавления нуля и умножению
на ноль соответственно.

Несмотря на то, что этот тип, очевидно, абсолютно бесполезен в рантайме, он бывает удобен для
статического анализа. Например, если функция в Python возвращает `NoReturn` (так там называется
bottom type), то весь код после её вызова считается недоступным.

<!-- }}} -->

#### <!-- {{{ -->[Зависимые типы](#dep-types) {#dep-types}

Представим себе функцию, которая получает на вход число `n` и возвращает на выходе массив
фиксированного размера `n`.

Здесь я имею в виду не вектор динамического размера, а именно массив: тип `T[n]` в C или `[n]T`
в Go.

Если записать такую функцию на псевдо-Go, то получится что-то в этом роде:

```go
func createArray(n int) [n]int {
    /* logic here */
}
```

В Go нет зависимых типов, поэтому объявить такую функцию мы не можем: значения из рантайма не могут
участвовать в образовании типов. Если же значения из рантайма можно «пробросить» на уровень типов,
то мы говорим, что в языке есть _зависимые типы_. Например, на Idris эта функция выглядела бы так:

```idris
-- Функция createArray принимает натуральное число `n` и возвращает массив целых чисел размера `n`
createArray : (n : Nat) -> Vect n Int
-- Если ей передали 0, то она возвращает пустой массив
createArray Z = Nil
-- В противном случае, она дописывает 0 в начало массива размера `n - 1`
-- Таким образом, рекурсивно функция `createArray` определена для любого натурального `n`
createArray (S x) = 0 :: (createArray x)
```

Зависимые типы — крайне редкая и сложная фича. Полноценно они реализованы только в нескольких
исследовательских языках (Agda, Idris, Lean, F*, ATS). Некие зачатки зависимых типов есть в Scala,
TypeScript, mypy, C++.

<!-- }}} -->

#### <!-- {{{ -->[Substructural types (линейные, аффинные и релевантные типы)](#substructural) {#substructural}

Substructural type systems определяют для типов три бинарных свойства: exchange, weakening и
contraction.  Первое из них нам не очень важно, потому что в реальных языках exchange почти всегда
разрешён. Остальные два, соответственно, формируют такую таблицу:

 Типы         | weakening | contraction
--------------|-----------|-------------
 Нормальные   | разрешён  | разрешён 
 Аффинные     | разрешён  | запрещён
 Релевантные  | запрещён  | разрешён
 Линейные     | запрещён  | запрещён

Если перевести слова weakening и contraction на человеческий язык, то они передают следующие свойства
типов:

* Если для типа запрещён weakening, то его можно использовать _не менее_ одного раза: нельзя создать
  значение типа, и ничего с ним не сделать.
* Если для типа запрещён contraction, то его можно использовать _не более_ одного раза: после
  первого и единственного использования значение исчезает, и использовать его более нельзя.

Надо понимать, что _использование_ может быть определено по-разному в зависимости от семантики
языка. Далее будут примеры.

##### [Аффинные типы](#affine-types) {#affine-types}

Самая частая версия этой фичи. Аффинные типы можно использовать не более одного раза: после того,
как значение было использовано, оно более недоступно. Они реализованы, например, в Rust:

```rust
struct S;

fn foo(x: S) {
    /* делаем что-нибудь с x */
}

let a = S;
// Используем `a`
foo(a);
// Ошибка: мы уже отдали `a` в функцию `foo()`, мы не можем сделать это ещё раз
foo(a);
```

Очевидно, подобное ограничение, реализованное наивно, сильно мешало бы писать любые практические
программы. В реальной жизни значение довольно часто надо использовать более одного раза.
Функциональные языки обычно решают эту проблему так:

```rust
fn foo(x: S) -> S {
    /* делаем что-нибудь с x */
    /* и возвращаем его обратно */
    x
}

let a = S;
// Используем `a`, получая его обратно из функции
let a = foo(a);
// Используем `a` ещё раз, его нам вернули
foo(a);
// Ошибка: больше не можем использовать `a`, потому что мы не забрали его обратно
foo(a);
```

Для императивного языка это всё ещё выглядит не очень практично, поэтому Rust использовал хитрость.
С точки зрения Rust, только передача _по значению_ считается использованием. Передавать что-то
по ссылке (_borrow_ в терминологии Rust) можно сколько угодно раз.

```rust
fn foo(x: S) {
    /* делаем что-нибудь с x */
}

fn bar(x: &S) {
    /* делаем что-нибудь с x по ссылке */
}

let a = S;
// Мы не отдаём `a`, а отдаём только ссылку на `a`.
bar(&a);
// Поэтому можем сделать это ещё раз.
bar(&a);
// Но если мы всё-таки отдадим `a`, то больше не сможем даже взять на него ссылку
foo(a);
// Ошибка: мы уже отдали `a` в `foo()`, теперь мы ничего не можем с ним сделать
bar(&a);
```

Аффинные типы есть в Rust, немного есть в C++ в виде move semantics, и ещё есть везде, где есть
линейные типы.

##### [Релевантные типы](#relevant-types) {#relevant-types}

Релевантные типы — это типы, которые можно использовать _не менее_ одного раза. Получив значение
такого типа, ты обязан что-то с ним сделать. Релевантные типы есть практически только там же, где
и линейные. К сожалению, языки, в которых есть линейные типы в массе своей недостаточно похожи на
что-либо привычное, чтобы быть хорошими примерами в этой шпаргалке, поэтому мне придётся снова
использовать Rust в этом качестве.

В Rust релевантные типы эмулируются аттрибутом `#[must_use]`.

```rust
#[must_use]
struct S;

fn foo() -> S {
    S
}

// Так нельзя: мы получаем значение типа `S` и не используем
foo();
// Но, к сожалению, так можно: поэтому `#[must_use]`-типы в Rust и нельзя назвать релевантными
let _ = foo();
// Можно ещё так, например
bar(&foo());
// Способов обмануть `#[must_use]`-аттрибут хватает
```

Если представить себе, что единственный способ избавиться от `#[must_use]`-типа — это передать его
куда-нибудь по значению (и, в конечном счёте, передать по значению в встроенную функцию `drop()`,
которая от него избавится), то это и получатся релевантные типы.

##### [Линейные типы](#linear-types) {#linear-types}

Здесь всё просто: линейные типы это такие, которые одновременно аффинные и релевантные, то есть
значения которых можно использовать ровно один раз. Линейные типы есть в Haskell, Idris, ATS, F* и
нескольких ещё менее известных языках.

В теории, линейные типы замечательно подходят для управления ресурсами: если каждый ресурс можно
использовать ровно один раз, то мы в точности знаем, когда он больше не нужен и, соответственно,
когда его можно освободить. Также это хорошо подходило бы для моделирования систем с несколькими
состояниями:

```rust
// Представим на секунду, что в Rust есть аттрибут `#[linear]`, который делает тип линейным

#[linear]
struct LockedLock;

#[linear]
struct UnlockedLock;

impl UnlockedLock {
    // Мы можем создать новый не-взятый лок
    fn new() -> UnlockedLock {
        UnlockedLock
    }

    // И мы можем взять его
    fn lock(self) -> LockedLock {
        drop(self);
        LockedLock
    }
}

impl LockedLock {
    // Уже взятый лок мы можем отпустить
    fn unlock(self) -> UnlockedLock {
        drop(self);
        UnlockedLock
    }

    // Или отпустить и сказать, что он нам больше не нужен
    fn unlock_and_drop(self) {
        drop(self);
    }
}

// Таким образом, если мы создали лок и взяли его, мы не можем взять его ещё раз
let lock = UnlockedLock::new();
let lock = lock.lock();
// Ошибка: `lock` теперь `LockedLock`, и у него метода `.lock()` нет
// Старый `lock` мы использовали, и он теперь недоступен
// Точно так же мы не сможем разблокировать один лок два раза
let lock2 = lock.lock();
// Мы также не можем забыть разблокировать лок: тогда он останется неиспользованным
// Нам нужно в явном виде его отпустить и дропнуть:
lock.unlock_and_drop();
```

<!-- }}} -->

### <!-- {{{ -->[Чисто функциональные языки и ссылочная прозрачность](#pure-functional) {#pure-functional}

Чисто функциональные языки — это языки, в которых каждая функция обладает свойством _ссылочной
прозрачности_ (или, формулируя более коротко, каждая функция — _чистая_). Определение чистой функции
очень простое: если вызов функции можно заменить на её возвращаемое значение, не изменив при этом
значимое поведение программы, то она чистая.

Например:

```go
// Эта функция — чистая
func add(x, y int) int {
    return x + y
}

// Эта функция не чистая — если заменить её на её возвращаемое значение,
// то внешняя переменная не изменится
func mutateArg(arg *int) int {
    *arg += 1;
    return *arg
}

// Эта функция не чистая — её значение зависит не только от её аргументов.
// Представим себе, что мы используем её в цикле — если мы заменим её вызов на возвращаемое
// значение, то мы будем получать одно и то же число на каждой итерации.
func getNum() int {
    return rand.Intn(100)
}

// Эта функция не чистая — если её заменить на возвращаемое значение (unit type),
// то вывода на экран не произойдёт
func hello() {
    fmt.Println("Hello, world!")
}
```

Легко можно заметить проблему: такое определение запрещает чистым функциям осуществлять любого
рода ввод-вывод. Соответственно, если в языке любая функция — чистая, то программа на этом языке
не может сделать ничего полезного и может быть оптимизирована до пустой.

> **N.B.:** Следующая секция очень грубо упрощает то, как работает Haskell. Я не хочу рассказывать про
монады в формате этого глоссария. Если тема вас заинтересовала, то рекомендую прочитать туториал 
[Learn You a Haskell for Great Good][lyhgg].

Эта проблема решается следующим способом: если программа на чисто функциональном языке не может
осуществлять ввод-вывод, то весь ввод-вывод должен осуществляться _вне программы_. Рассмотрим
следующий код на Haskell:

```haskell
-- Функция main не принимает аргументов и возвращает объект типа `IO ()`
main :: IO ()
main = do
    -- Получаем строку с клавиатуры
    line <- getLine
    -- И выводим её на экран
    print line
```

Может показаться, что `main` — не чистая функция, так как она получает ввод с клавиатуры и выводит
данные на экран. На самом деле, функция `main` этого не делает. Вместо этого она составляет нечто
вроде плана выполнения, в котором написано, что после получения строки с клавиатуры, её нужно вывести
на экран. `IO ()` и есть тип этого плана.

Рантайм Haskell выполняет план, полученный от функции `main`. Из этого есть интересное следствие:
если тот же объект не вернуть из `main` (а, например, просто положить в переменную), то он не будет
выполнен, и никаких побочных эффектов не произойдёт.  Таким образом, функция `main` — чистая: её
можно вызвать из любой части программы, сколько угодно раз, и она вернёт один и тот же объект во
всех случаях. Все побочные эффекты происходят вне программы, в рантайме Haskell.

<!-- Links -->
[lyhgg]: http://learnyouahaskell.com/

<!-- }}} -->

### <!-- {{{ -->[Полиморфизм](#polymorphism) {#polymorphism}

Полиморфизм — это возможность передать в одну функцию объекты разных типов. Есть несколько основных
способов реализации полиморфизма, которые глобально делятся на два подхода: _номинативный_ и
_структурный_.

* Номинативный полиморфизм требует в явном виде указать, что конкретный тип подходит для использования
  в нужном качестве
* Структурный полиморфизм определяет это неявно, исходя из свойств типа

Рассмотрим основные варианты полиморфизма.

#### [Наследование](#inheritance) {#inheritance}

Полиморфизм, реализованный через наследование, позволяет передать класс-наследник туда, где ожидается
базовый класс. Это подвид номинативного полиморфизма: класс-наследник в явном виде указывает свой
суперкласс. Этот вид полиморфизма наиболее распространён в классических языках, но не очень популярен
в новых (и, стало быть, в тех, которые мы будем в основном рассматривать).

Отличающая особенность наследования в том, что подкласс наследует и интерфейс, и реализацию суперкласса.
Это нехакрактерно для других видов полиморфизма.

#### [Структурные интерфейсы](#structural-interfaces) {#structural-interfaces}

Структурные интерфейсы задают набор методов (и, иногда, полей), которые должен реализовывать тип,
чтобы подходить под интерфейс. Примером структурных интерфейсов могут быть interface types из Go
или `typing.Protocol` из Python/MyPy. В некотором роде, «утиная типизация» динамических языков —
это тоже пример полиморфизма через структурные интерфейсы:

```python
# Если попытаться записать тип этой функции, не зная ничего больше про программу,
def modify_obj(obj):
    obj.a = 0
    obj.b = "Foo"

# то получится что-то вроде:
class ModifyObjArg(Protocol):
    a: int
    b: str

def modify_obj(obj: ModifyObjArg) -> None:
   ... 
```

Подобный же вид полиморфизма предлагают шаблоны из C++ (и макросы в большинстве языков):

```cpp
// Тип этой функции буквально:
// «из двух каких-нибудь штук одного типа, которые можно сложить в результат их сложения»
template<typename T> auto add(T a, T b) -> decltype(a + b) {
    return a + b;
}
```

Преимущество такого подхода заключается в том, что он позволяет описать интерфейс для нескольких
несвязанных типов пост-фактум, даже если они приходят из разных библиотек. Достаточно только, чтобы
совпадали имена и сигнатуры методов.

В этом же заключается и главный недостаток — так как объявлять намерение реализовать интерфейс
необязательно, то интерфейс можно реализовать случайно, и, соответственно, неправильно.

#### [Номинативные интерфейсы](#nominative-interfaces) {#nominative-interfaces}

Также известны как «трейты» и «тайпклассы». Встречаются, например, в Haskell, Idris, Rust.
Во многом аналогичны структурным интерфейсам, кроме одной детали: чтобы тип соответствовал
номинативному интерфейсу, про него нужно в явном виде это написать.

```rust
// Трейт `Foo` требует реализации метода `.foo(self)`
trait Foo {
    fn foo(self);
}

struct A;
struct B;

// `A` не реализует `Foo`: несмотря на то, что у `A` есть метод `.foo(self)`,
// он не принадлежит к нужному трейту
impl A {
    fn foo(self) {}
}

// `B` реализует `Foo`: мы написали это в явном виде
impl Foo for B {
    fn foo(self) {}
}
```

Интересным следствием такой идеи становится то, что она позволяет добавить новые методы к уже
существующим типам:

```rust
// Встроенный числовой тип реализует `Foo`: почему бы и нет?
impl Foo for i32 {
    fn foo(self) {}
}

0.foo()
```

Это даёт некую степень расширяемости, которой нет у структурных интерфейсов: так, в Go, чтобы
добиться схожих результатов (сделать, чтобы встроенный тип реализовывал новый интерфейс), обычно
приходится просто создать новый тип, обернув в него старый.

##### [Бонус: номинативные интерфейсы и Тьюринг-полнота](#nominative-bonus) {#nominative-bonus}

**Note:** В этой секции мы будем использовать `number` как синоним для некоего числового типа, чтобы
не вдаваться в то, как устроены числа в Rust.

Представим себе, что мы хотим описать операцию умножения как номинативный интерфейс. Первой мыслью
будет написать что-то вроде:

```rust
trait Mul {
    // `Self` это тип `self`
    fn mul(self, other: Self) -> Self;
}
```

Этот интерфейс хорошо подходит для чисел, но не позволяет описать, например, умножение вектора на
число: он требует, чтобы оба множителя были одинакового типа. Снимем это ограничение:

```rust
// Теперь `Mul` это дженерик-трейт, он принимает тип в качестве параметра
// Мы можем читать его как «умножить на Other»
// Вектор, например, может реализовывать `Mul<Vector>` и `Mul<number>` одновременно
trait Mul<Other> {
    // Если мы умножим вектор на число, мы получим вектор — тот же тип, что и `self`
    fn mul(self, other: Other) -> Self;
}
```

Этот интерфейс справляется с умножением вектора на число, но всё ещё недостаточно хорош для описания,
например, скалярного умножения двух векторов. Он предполагает, что выходной тип всегда равен типу
левого аргумента, а скалярное умножение векторов даёт число. Исправим это:

```rust
trait Mul<Other> {
    // Теперь мы позволяем при реализации трейта указать, какой тип получается в итоге
    // Например, умножение вектора на число укажет
    // `type Output = Vector;`
    // , а для скалярного умножения векторов нужно будет указать
    // `type Output = number;`
    type Ouptut;

    // Метод .mul() теперь возвращает тип `Output`, а не `Self`
    fn mul(self, other: Other) -> Self::Output;
}
```

Важное отличие типов-аргументов (как `Other`) от _ассоциированных типов_ (как `Output`): для каждого
набора типов-аргументов, есть только один набор ассоциированных типов. Иными словами, хотя вектор
можно умножить на разные типы, для каждой из этих операций есть только один тип, который может получиться
в результате.

Оказывается, что набор инструментов, который нам только что потребовался (номинативные интерфейсы,
типы-аргументы и ассоциированные типы) достаточен, чтобы система типов языка была Тьюринг-полной.
В самом деле, мы можем рассмотреть трейты как функции из набора типов-аргументов в набор ассоциированных
типов. Это позволяет нам выразить лямбда-исчисление, которое Тьюринг-полное. Кто-то даже реализовал
[Brainfuck внутри системы типов Rust][rust-brainfuck], потому что естественно кто-то это сделал.

Печальное следствие Тьюринг-полноты: неразрешимость. Если система типов достаточно мощная, чтобы
описать интерфейс выше (умножение значения на значение другого типа, где результат — значение
третьего типа), то проверку типов в программе буквально нельзя завершить за предсказуемо конечное
время. От этого страдает не только Rust: в C++, Scala, Haskell с некоторыми расширениями, и многих
других языках также невозможно проверить типы за конечное время.

<!-- Links: -->
[rust-brainfuck]: https://sdleffler.github.io/RustTypeSystemTuringComplete/

<!-- }}} -->

### [See also](#see-also) {#see-also}

* [What Color is Your Function][wciyf]: про цветную и бесцветную асинхронность
* [Abstracting away correctness][correctness1]: про типы и дизайн API
* [Aiming for correctness with types][correctness2]: про типы и дизайн API, снова
* [Working with strings in Rust][strings]: про строки в C (sic), и ещё, да, про типы и дизайн API
* [The Pain Of Real Linear Types in Rust][linear-pain]: про линейные типы в контексте Rust
* [Learn You a Haskell for Great Good][lyhgg]: учебник по Haskell, который даёт представление о чистых языках
* Type-Driven Development with Idris: учебник по Idris, который даёт много представления о типах

<!-- Links: -->
[wciyf]: https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/
[correctness1]: https://fasterthanli.me/articles/abstracting-away-correctness
[correctness2]: https://fasterthanli.me/articles/aiming-for-correctness-with-types
[strings]: https://fasterthanli.me/articles/working-with-strings-in-rust
[linear-pain]: https://gankra.github.io/blah/linear-rust/
